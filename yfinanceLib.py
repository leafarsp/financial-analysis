# -*- coding: utf-8 -*-
"""testeyfinance.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q5VxmQTWavyqQc3mtjZ2kJcawLbijZNE
"""

# pip install yfinance
#!pip install yahooquery

import yfinance as yf
#pip inimport requests
import pandas as pd
import matplotlib.pyplot as plt
from yahooquery import Ticker
import numpy as np
from io import StringIO

# from google.colab import drive
# drive.mount('/content/drive')

def buscar_dados_acao(ticker,period='1y'):
    dados = None
    try:
        acao = yf.Ticker(ticker)
        dados = acao.history(period=period)

        if dados.empty:
            print("Nenhum dado encontrado para o ticker fornecido.")


        # print(f"Dados da ação {ticker}:")
        # print(dados[['Open', 'High', 'Low', 'Close', 'Volume']])
        # plt.plot(dados['Close'])
    except Exception as e:
        print(f"Erro ao buscar dados: {e}")
    return dados


def loadTickers(tickers_xlsx, notValidTickers = None):
  tickersdf = pd.read_excel(tickers_xlsx)

  NotValidTickersdf = pd.read_csv(notValidTickers)
  if notValidTickers is not None:
    tickersdf = tickersdf[~tickersdf["Ticker"].isin(NotValidTickersdf["Not Valid Ticker"])]

  tickersdf['Ticker']=tickersdf['Ticker']+".SA"
  tickersdf = tickersdf.dropna()
  ticker_list = tickersdf['Ticker'].to_list()

  return ticker_list

def loadAllTickers(tickers_list_xls):
  tickersdf = pd.read_excel(tickers_list_xls)
  #
  tickersdf['Ticker']=tickersdf['Ticker']+".SA"
  tickersdf = tickersdf.dropna()
  ticker_list = tickersdf['Ticker'].to_list()

  return tickersdf


  # period option: ['1d', '5d', '7d', '60d', '1mo', '3mo', '6mo', '1y', '2y', '5y', '10y', 'ytd', 'max']
def fetch_prices(ticker_list, period='1y', interval='1d'):



  all_symbols = " ".join(ticker_list)
  tickers = Ticker(all_symbols, asynchronous=True)
  df = tickers.history(period=period, interval=interval)
  return df

#values: open,high,low,close,volume,adjclose,dividends,splits, market_cap, return
def transpose_stock_data(dataframe, values='adjclose'):


  # Carregar os dados
  df = dataframe

  # Check if the 'date' column exists, if not assume it's 'index'
  if 'date' not in df.columns:
      df = df.reset_index()
      df.rename(columns={'index': 'date'}, inplace=True)

  # print(df['date'])

  # Remove o timezone manualmente (como string)
  df['date'] = df['date'].astype(str).str.replace(r'(\\+|\\-)\d{2}:\d{2}$', '', regex=True)


  # Remover informações extras de horário, mantendo apenas a data
  df['date'] = pd.to_datetime(df['date'] , errors='coerce', dayfirst=True)


  # Calcular a capitalização de mercado

  df['market_cap'] = df['close'] * df['volume']



  # Criar um índice único de datas dos últimos 365 dias
  start_date = df['date'].min()
  end_date = df['date'].max()
  all_dates = pd.date_range(start=start_date, end=end_date, freq='D')

  #remove linhas duplicadas
  df = df[~df.duplicated(subset=['symbol', 'date'], keep=False)]


  stocks_col = df.pivot(index='date', columns='symbol').columns.to_list()
  stocks_param = [ 'open','high','low','close','volume','adjclose','dividends',
                  'splits', 'market_cap', 'return','logreturn']

  # Cria um df multi-index
  colunas = pd.MultiIndex.from_product([stocks_col, stocks_param])
  df_result = pd.DataFrame(index=df.index , columns=colunas)

  # Reorganizar os dados

  if values == 'return':
    pivot_df = df.pivot(index='date', columns='symbol', values='adjclose')
    for col in pivot_df.columns[1:]:  # Ignorando a coluna de data
      pivot_df[col] = pivot_df[col].pct_change()
  else:
    pivot_df = df.pivot(index='date', columns='symbol', values=values)

  # Reindexar para garantir que todas as datas estejam presentes
  pivot_df = pivot_df.reindex(all_dates)

  # Preencher valores ausentes com os do dia anterior
  pivot_df.fillna(method='ffill', inplace=True)

  return pivot_df

#values: open,high,low,close,volume,adjclose,dividends,splits, market_cap, return
def transpose_stock_data_all(dataframe, values='adjclose'):

    df = dataframe.copy()

    # Garantir que a coluna 'date' existe
    if 'date' not in df.columns:
        df = df.reset_index()
        df.rename(columns={'index': 'date'}, inplace=True)

    # Limpar timezone
    df['date'] = df['date'].astype(str).str.replace(r'(\+|\-)\d{2}:\d{2}$', '', regex=True)
    df['date'] = pd.to_datetime(df['date'], errors='coerce', dayfirst=True)

    # Calcular market_cap
    df['market_cap'] = df['close'] * df['volume']

    # Criar intervalo de datas
    start_date = df['date'].min()
    end_date = df['date'].max()
    all_dates = pd.date_range(start=start_date, end=end_date, freq='D')

    # Remover duplicatas
    df = df.drop_duplicates(subset=['symbol', 'date'])

    # Obter lista única de símbolos
    symbols = df['symbol'].unique()

    # Parâmetros padrão
    std_param = ['close', 'adjclose', 'market_cap']

    all_param = ['close', 'adjclose', 'market_cap', 'return', 'log_return']
    # Criar MultiIndex para colunas
    colunas = pd.MultiIndex.from_product([symbols, all_param])

    # Criar DataFrame de retorno com índice de datas completas
    df_result = pd.DataFrame(index=all_dates, columns=colunas)

    for param in std_param:
        # Pivotar o DataFrame para esse parâmetro
        pivot_df = df.pivot(index='date', columns='symbol', values=param)

        # Reindexar e preencher dados ausentes
        pivot_df = pivot_df.reindex(all_dates)
        pivot_df.ffill(inplace=True)
        pivot_df.bfill(inplace=True)

        # Preencher o df_result

        for symbol in symbols:
            if symbol in pivot_df.columns:
                df_result[(symbol, param)] = pivot_df[symbol]


    # Calcula os retornos
    df_return = df_result.xs('adjclose',axis=1,level=1).pct_change()
    df_return.ffill(inplace=True)
    df_return.bfill(inplace=True)

    for symbol in symbols:
        if symbol in pivot_df.columns:
           df_result[(symbol, 'return')] = df_return[symbol]
           df_result[(symbol, 'log_return')] = np.log(df_return[symbol] + 1)

    return df_result

# Average daily return

def calculate_avg_daily_return(df_ticker_return):
  # local_df = df[ticker,'return']
  local_df = df_ticker_return

  # Calcular o produto acumulado: ∏ (1 + R_i)
  product = np.prod(1 + local_df)

  # Número de períodos (por padrão, usamos 252 dias úteis)
  n = len(local_df)

  # Calcular o retorno médio geométrico conforme a fórmula
  avg_daily_return = product ** (1/n) - 1

  return avg_daily_return

def calculate_avg_monthly_return(df_ticker_return):

  avg_daily_ret = calculate_avg_daily_return(df_ticker_return)
  avg_monthly_ret = (1 + avg_daily_ret) ** (30) - 1
  return avg_monthly_ret

# Average daily log return

def calculate_avg_daily_log_return(df, ticker):
  local_df = df[ticker,'log_return']


  # Calcular o produto acumulado:  sum (r_i)
  sum = np.sum(1 + local_df)

  # Número de períodos (por padrão, usamos 252 dias úteis)
  n = len(local_df)

  # Calcular o retorno médio conforme a fórmula
  avg_daily_return = sum * (1/n)

  return avg_daily_return

def calculate_avg_monthly_log_return(df, ticker):
  avg_daily_log_ret = calculate_avg_daily_log_return(df, ticker)
  # TODO: encontrar fórmula para calcular o retorno log médio mensal
  # avg_monthly_log_ret = (1 + avg_daily_log_ret) ** (1/30) - 1

  return None

"""Criar data frames"""

def get_avg_daily_monthly_returns(df):
  columns = ['Ticker', 'Avg Daily Return', 'Avg Monthly Return']
  tickers = df.columns.get_level_values(0).unique().tolist()
  #df_avg_returns = pd.DataFrame(columns=columns)

  data = []
  for ticker in tickers:
    local_df = df[ticker,'return']
    avg_daily_return = calculate_avg_daily_return(local_df)
    avg_monthly_return = calculate_avg_monthly_return(local_df)

    data.append([ticker, avg_daily_return, avg_monthly_return])

  df_avg_returns = pd.DataFrame(data, columns=columns)
  return df_avg_returns



def get_tickers_by_sector_subsector_segment(df_tickers, sector='all', subsector='all', segment='all'):
  return_df = None
  df_columns = df_tickers.columns

  return_df = pd.DataFrame(columns=df_columns)
  i = 0
  result_rows = []
  for ticker in df_tickers['Ticker']:
    i +=  1


    ticker_info = df_tickers[df_tickers['Ticker'] == ticker]
    ticker_segment = ticker_info['SEGMENTO'].values[0]
    ticker_subsector = ticker_info['SUBSETOR'].values[0]
    ticker_sector = ticker_info['SETOR ECONÔMICO'].values[0]


    if (segment == 'all') or (ticker_segment == segment):
      # print(ticker_subsector == 'all')
      if (subsector == 'all') or (ticker_subsector == subsector):

        if sector == 'all' or ticker_sector == sector:
          # print(f'{i} - {ticker}, seg = {ticker_segment}, subsec = {ticker_subsector}, sec = {ticker_sector}')
          result_rows.append(ticker_info)
  if len(result_rows) > 0:
    return_df = pd.concat(result_rows)
    # print(f'{ticker}, seg = {ticker_segment}, subsec = {ticker_subsector}, sec = {ticker_sector}')
  return return_df




# prompt: Considere o dataframe gerado na célula anterior. Crie um dataframe que retorne a média dos retornos apenas o "return", não o "log_return" a partir de um outro dataframe que contenha um conjunto específico de tickers. Dessa forma, o dataframe resultante vai ter a coluna date (que será o index, da mesma forma que o dataframe recebido como primeiro parâmetro), uma coluna para cada ticker, e a coluna avg_return

def get_avg_returns_by_tickers(df_returns, df_tickers_list):
  """
  Calcula a média dos retornos diários para um conjunto específico de tickers.

  Args:
    df_returns: DataFrame com MultiIndex nas colunas (Ticker, métrica).
    df_tickers_list: DataFrame contendo a lista de tickers.

  Returns:
    DataFrame com retornos diários dos tickers válidos + média (avg_return).
  """
  tickers_to_analyze = df_tickers_list['Ticker'].tolist()

  # Garantir que só usaremos tickers que estão presentes no df_returns
  available_tickers = df_returns.columns.get_level_values(0).unique()
  valid_tickers = [ticker for ticker in tickers_to_analyze if ticker in available_tickers]

  # Verificar se há pelo menos um ticker válido
  if not valid_tickers:
    raise ValueError("Nenhum dos tickers fornecidos está presente no DataFrame de retornos.")

  # Filtrar os retornos
  df_filtered_returns = df_returns.loc[:, pd.IndexSlice[valid_tickers, 'return']]

  # Remover o MultiIndex nas colunas
  df_filtered_returns.columns = df_filtered_returns.columns.get_level_values(0)

  # Calcular a média
  df_filtered_returns['avg_return'] = df_filtered_returns.mean(axis=1)

  return df_filtered_returns


def integrate_returns(df_returns):
  """
  Integra os retornos diários em um DataFrame de retornos acumulados.

  Args:
    df_returns: DataFrame contendo os retornos diários. Assume-se que
                o índice é a data e a(s) coluna(s) contêm os retornos diários.

  Returns:
    Um DataFrame com os retornos acumulados. O índice é a data.
  """
  # Para calcular retornos acumulados, somamos 1 a cada retorno diário e calculamos o produto acumulado.
  # O produto acumulado reflete o crescimento do capital investido.
  # Para obter apenas o retorno acumulado (excluindo o capital inicial), subtraímos 1.
  df_integrated = (1 + df_returns).cumprod() - 1
  return df_integrated

def plot_returns(df_integrated_all, title='Retorno médio no setor',savepath=None, showplt=True):
  # Cria a figura
  plt.figure(figsize=(12, 6))

  # Plota cada coluna individualmente
  for column in df_integrated_all.columns:
      if column == 'avg_return':
          # Linha da média com traço mais grosso e cor destacada
          plt.plot(df_integrated_all.index, df_integrated_all[column], label='avg_return', linewidth=2.5, color='black')
      else:
          # Outras linhas mais finas e discretas
          plt.plot(df_integrated_all.index, df_integrated_all[column],  label=column, linewidth=0.8, alpha=0.5)

  plt.title(title)
  plt.xlabel("Data")
  plt.ylabel("Retorno Acumulado")
  plt.grid(True)
  plt.legend(loc='best', fontsize='small', ncol=2)
  plt.tight_layout()
  if savepath is not None:
     plt.savefig(savepath, dpi=300)
  if showplt:
    plt.show()


def calculateDaylyMonthlyRetsByCat(df_tickers, df_stock_data):


    
    sectors = df_tickers['SETOR ECONÔMICO'].unique().tolist()
    subsectors = df_tickers['SUBSETOR'].unique().tolist()

    

    df_columns = ['sector','subsector','segment','avg_daily_ret','avg_monthly_ret']

    df_avg_daily_monthly_returns = pd.DataFrame(columns=df_columns)

    for sector in sectors:
        df_test = get_tickers_by_sector_subsector_segment(df_tickers, sector = sector)
        df_avg_returns_selected = get_avg_returns_by_tickers(df_stock_data, df_test)
        sector_avg_daily_ret = calculate_avg_daily_return(df_avg_returns_selected['avg_return'])
        sector_avg_monthly_ret = calculate_avg_monthly_return(df_avg_returns_selected['avg_return'])
        
        data_line = [sector,'','',sector_avg_daily_ret,sector_avg_monthly_ret] 
        

        # Adiciona a linha no final
        df_avg_daily_monthly_returns.loc[len(df_avg_daily_monthly_returns)] = data_line
      
        
        # Exemplo de uso com o dataframe de retorno médio selecionado anteriormente:
        df_integrated_avg_returns = integrate_returns(df_avg_returns_selected)
        

        for subsector in subsectors:
            df_test = get_tickers_by_sector_subsector_segment(df_tickers, sector = sector, subsector = subsector)
            if df_test is not None:
                try:
                    df_avg_returns_selected = get_avg_returns_by_tickers(df_stock_data, df_test)

                    subsector_avg_daily_ret = calculate_avg_daily_return(df_avg_returns_selected['avg_return'])
                    subsector_avg_monthly_ret = calculate_avg_monthly_return(df_avg_returns_selected['avg_return'])
                    data_line = [sector,subsector,'',subsector_avg_daily_ret,subsector_avg_monthly_ret] 
        
                    # Adiciona a linha no final
                    df_avg_daily_monthly_returns.loc[len(df_avg_daily_monthly_returns)] = data_line

                except Exception as e:
                    if str(e) != 'Nenhum dos tickers fornecidos está presente no DataFrame de retornos.':
                        print(f'Error in {subsector}, error: {e}')

    return df_avg_daily_monthly_returns

